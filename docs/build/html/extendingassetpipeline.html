

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extending the Asset Pipeline &mdash; Asset Pipeline  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="Asset Pipeline  documentation" href="index.html"/>
        <link rel="next" title="Asset Rules" href="assetrules.html"/>
        <link rel="prev" title="Utility Classes" href="utilityclasses.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Asset Pipeline
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Asset Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="batchcompiler.html">Batch Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="testcompiler.html">TestCompiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="jitcompiler.html">JIT Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilityclasses.html">Utility Classes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Extending the Asset Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modules">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compiler">Compiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion">Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency">Dependency</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discovery">Discovery</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-conversion-process">The Conversion Process</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recursive-conversion">Recursive Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-recursive-conversion">Non-Recursive Conversion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-converters-and-conversion-rules">Writing Converters and Conversion Rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#converters">Converters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructor">Constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#createdependencies">createDependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert">convert</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#absolute-vs-relative-paths">Absolute vs Relative Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency-list">Dependency List</a></li>
<li class="toctree-l3"><a class="reference internal" href="#errors-and-exceptions">Errors and Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion-rules">Conversion Rules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-compilers">Writing Compilers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asset-compiler">Asset Compiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discovery-callbacks">Discovery Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#task-callbacks">Task Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#converter-callbacks">Converter Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion-callback">Conversion Callback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cache-callbacks">Cache Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-callbacks">Message Callbacks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#registering-converters-and-conversion-rules">Registering Converters and Conversion Rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initiating-a-build">Initiating a Build</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-plugins">Writing Plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plugin-loader">Plugin Loader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#converter-plugin">Converter Plugin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-unit-tests">Writing Unit Tests</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="assetrules.html">Asset Rules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Asset Pipeline</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Extending the Asset Pipeline</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/extendingassetpipeline.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="extending-the-asset-pipeline">
<h1>Extending the Asset Pipeline<a class="headerlink" href="#extending-the-asset-pipeline" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id4">Overview</a></li>
<li><a class="reference internal" href="#modules" id="id5">Modules</a><ul>
<li><a class="reference internal" href="#compiler" id="id6">Compiler</a></li>
<li><a class="reference internal" href="#conversion" id="id7">Conversion</a></li>
<li><a class="reference internal" href="#dependency" id="id8">Dependency</a></li>
<li><a class="reference internal" href="#discovery" id="id9">Discovery</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-conversion-process" id="id10">The Conversion Process</a><ul>
<li><a class="reference internal" href="#recursive-conversion" id="id11">Recursive Conversion</a></li>
<li><a class="reference internal" href="#non-recursive-conversion" id="id12">Non-Recursive Conversion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-converters-and-conversion-rules" id="id13">Writing Converters and Conversion Rules</a><ul>
<li><a class="reference internal" href="#converters" id="id14">Converters</a></li>
<li><a class="reference internal" href="#absolute-vs-relative-paths" id="id15">Absolute vs Relative Paths</a></li>
<li><a class="reference internal" href="#dependency-list" id="id16">Dependency List</a></li>
<li><a class="reference internal" href="#errors-and-exceptions" id="id17">Errors and Exceptions</a></li>
<li><a class="reference internal" href="#conversion-rules" id="id18">Conversion Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-compilers" id="id19">Writing Compilers</a><ul>
<li><a class="reference internal" href="#asset-compiler" id="id20">Asset Compiler</a></li>
<li><a class="reference internal" href="#discovery-callbacks" id="id21">Discovery Callbacks</a></li>
<li><a class="reference internal" href="#task-callbacks" id="id22">Task Callbacks</a></li>
<li><a class="reference internal" href="#converter-callbacks" id="id23">Converter Callbacks</a></li>
<li><a class="reference internal" href="#conversion-callback" id="id24">Conversion Callback</a></li>
<li><a class="reference internal" href="#cache-callbacks" id="id25">Cache Callbacks</a></li>
<li><a class="reference internal" href="#message-callbacks" id="id26">Message Callbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registering-converters-and-conversion-rules" id="id27">Registering Converters and Conversion Rules</a><ul>
<li><a class="reference internal" href="#initiating-a-build" id="id28">Initiating a Build</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-plugins" id="id29">Writing Plugins</a><ul>
<li><a class="reference internal" href="#plugin-loader" id="id30">Plugin Loader</a></li>
<li><a class="reference internal" href="#converter-plugin" id="id31">Converter Plugin</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-unit-tests" id="id32">Writing Unit Tests</a></li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id4">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The asset pipeline is designed to be flexible and extendable. To extend
the asset pipeline, developers can create new converters and conversion
rules for the back end, or new compilers for the front end.</p>
<p>Converters and conversion rules are standalone modules of code that can
be registered with the asset pipeline. Conversion rules define what
files can be converted through the asset pipeline, whereas converters
contain the actual conversion logic. Converters are also required to
inform the asset pipeline of any dependency a source asset may have,
after which the asset pipeline will ensure that these dependencies are
up to date and built.</p>
<p>Compilers are executable modules that provide a front-end interface to
the asset pipeline. There are three compilers provided with BWT: the
Batch Compiler, JIT Compiler, and Test Compiler. You can design
additional compilers to suit your needs (for example, compilers
providing graphical interfaces or progress feedback).</p>
</div>
<div class="section" id="modules">
<h2><a class="toc-backref" href="#id5">Modules</a><a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<p>The asset pipeline itself is divided into four library modules—the
compiler, conversion, dependency, and discovery modules. When writing
your own extensions for the asset pipeline, you should not need to
modify these libraries and should treat the entire asset pipeline as a
black box. The following descriptions are intended purely as a summary
of how the asset pipeline operates.</p>
<div class="section" id="compiler">
<h3><a class="toc-backref" href="#id6">Compiler</a><a class="headerlink" href="#compiler" title="Permalink to this headline">¶</a></h3>
<p>The compiler module contains the front-end compiler interface and the
default base implementation of the compiler (asset_compiler). All
user-defined compilers must inherit from the asset_compiler base class
and not the compiler interface. This has been enforced by making the
constructor of the compiler interface private, and only available to the
asset_compiler base class. The asset_compiler provides a number
callback functions that can be overloaded to monitor the progress of the
asset pipeline during discovery and conversion phases.</p>
</div>
<div class="section" id="conversion">
<h3><a class="toc-backref" href="#id7">Conversion</a><a class="headerlink" href="#conversion" title="Permalink to this headline">¶</a></h3>
<p>The conversion module is responsible for processing conversion tasks,
checking dependency hashes and invoking the appropriate converters. It
contains the converter interface which all user-defined asset converters
must derive from, the conversion_task (a data struct that is used to
track the status of an asset during conversion), the task_processor (a
class which processes a queue of tasks on multiple threads, resolving
any interdependencies), and the content_addressable_cache (a static
class that acts an extension to the task_processor to allow for faster
task processing).</p>
</div>
<div class="section" id="dependency">
<h3><a class="toc-backref" href="#id8">Dependency</a><a class="headerlink" href="#dependency" title="Permalink to this headline">¶</a></h3>
<p>The dependency module is a simple data library that contains the
different dependency structures that the asset pipeline knows how to
handle. It contains the dependency base, the converter_dependency,
converter_params_dependency, intermediate_file_dependency,
output_file_dependency, directory_dependency, and
source_file_dependency implementations and the dependency_list. As
simple data structures, the only functionality the dependency classes
provide are serialising to and from disk and generating dependency
hashes. The dependency_list class is a slightly more complicated data
structure that maintains a list of primary and secondary dependencies
associated with a source asset and a list of output files generated by
the source asset. The dependency_list structure represents the
<code class="docutils literal"><span class="pre">.deps</span></code> files that are generated by the asset pipeline during
conversion.</p>
</div>
<div class="section" id="discovery">
<h3><a class="toc-backref" href="#id9">Discovery</a><a class="headerlink" href="#discovery" title="Permalink to this headline">¶</a></h3>
<p>The discovery module is responsible for the task collection that occurs
during the discovery phase of the asset pipeline. It contains the
task_finder class, which iterates directories and files on disk,
searching for potential source assets eligible for conversion, and the
conversion_rule interface, the interface all user-defined conversion
rules must implement. Conversion rules are used by the task_finder to
determine which files on disk can be converted.</p>
</div>
</div>
<div class="section" id="the-conversion-process">
<h2><a class="toc-backref" href="#id10">The Conversion Process</a><a class="headerlink" href="#the-conversion-process" title="Permalink to this headline">¶</a></h2>
<p>A conversion task is created for every asset that the asset pipeline
attempts to convert. A conversion task contains:</p>
<ul class="simple">
<li>the file name of the asset being converted,</li>
<li>the id and version of the converter to be used,</li>
<li>any parameters to be passed to the converter,</li>
<li>the status of the conversion&#8217;s progress, and</li>
<li>links to any dependent conversion tasks for the asset.</li>
</ul>
<p>To ensure minimal effort is spent processing tasks, the asset pipeline
first attempts to determine if an asset needs to be converted at all. To
do this, it attempts to deduce if an asset, any of its dependencies, or
any of its outputs have changed since the last time the asset was
processed. To track this, the asset pipeline uses <strong>deps</strong> files.</p>
<p>When an asset is processed, its deps file is queried from disk. If no
deps file exists, a primary deps file is created. A primary deps file
contains all the primary dependencies of a source asset. The primary
dependencies of an asset are the asset source file itself, and the
converter id, converter version and converter parameters required to
convert the asset. If a deps file is found on disk, the stored primary
dependencies are checked to see if they are up to date. If the primary
dependencies are up not up to date, any secondary dependencies stored in
the deps file are considered invalid and need to be regenerated. To
regenerate the secondary dependencies, the converter for the asset is
invoked via the converter function <code class="docutils literal"><span class="pre">createDependencies</span></code>.</p>
<p>Once the secondary dependencies have been generated, the asset pipeline
must then verify that these dependencies are also up to date. As
secondary dependencies can include dependencies on compiled assets, the
asset pipeline may be required to trigger subtasks at this point. The
asset pipeline has two modes of operation for accomplishing this:
recursive conversion and non-recursive conversion.</p>
<div class="section" id="recursive-conversion">
<h3><a class="toc-backref" href="#id11">Recursive Conversion</a><a class="headerlink" href="#recursive-conversion" title="Permalink to this headline">¶</a></h3>
<p>This conversion mode blocks the current thread processing a task, and
recursively triggers conversion tasks of any sub dependencies. This has
the benefit of simplicity and can be easily debugged, as the entire
hierarchy of dependencies that triggered the conversion of a task can be
viewed in the debug callstack. Complications do still arise with this
method when multiple tasks being processed on separate threads have
dependencies on the same subtask. In this case, the first thread to
request the common subtask will trigger the conversion of the subtask
while any subsequent threads will be required to block and wait for the
first thread to finish. The drawback to this method is that when using
large root tasks which trigger multiple subtasks, all of these subtasks
must be processed on the same thread as the root parent task. For
example, if a task to convert a space triggers multiple subtasks for
models, textures and shaders, all of those subtasks need to be processed
on the thread used to convert the space. This reduces the benefit of the
parallel conversion capabilities that the asset pipeline provides.</p>
</div>
<div class="section" id="non-recursive-conversion">
<h3><a class="toc-backref" href="#id12">Non-Recursive Conversion</a><a class="headerlink" href="#non-recursive-conversion" title="Permalink to this headline">¶</a></h3>
<p>To maximise the parallel-conversion capabilities of the asset pipeline,
a non-recursive conversion mode is provided. In this mode, whenever a
parent task is determined to have a subtask that must be converted, the
parent task is paused and pushed back into the asset pipeline task
queue. The asset pipeline goes through a task management process to
ensure that the next time the parent task is processed, all of its
subtasks, and any further recursive subtasks have been processed to
completion. The asset pipeline also detects and protects against cyclic
dependencies between assets. This mode of operation is the more
efficient of the two modes of operation, but in this mode dependencies
between assets can be harder to debug.</p>
<p>After all the secondary dependencies of a task have been processed, the
hashes of the dependencies are checked against the assets deps file. If
the dependencies match, the deps file is then checked for the expected
outputs of the asset. If the expected outputs match those on disk the
task is considered up to date and conversion is skipped. If the
secondary dependencies do not match, or the expected outputs of the
asset do not match, the converter for the asset is invoked to convert
the asset via the converter function convert.</p>
<p>This conversion process is repeated for every conversion task discovered
by the asset pipeline.</p>
</div>
</div>
<div class="section" id="writing-converters-and-conversion-rules">
<h2><a class="toc-backref" href="#id13">Writing Converters and Conversion Rules</a><a class="headerlink" href="#writing-converters-and-conversion-rules" title="Permalink to this headline">¶</a></h2>
<p>The asset pipeline operates in two phases: the discovery phase and the
conversion phase. During the discovery phase, the asset pipeline
searches for files on disk that it can convert and creates conversion
tasks for them. During the conversion phase, the asset pipeline does the
actual asset conversion. Conversion rules are primarily used during the
discovery phase and converters during the conversion phase. In most
cases, when designing a new converter, you will need to create a
converter and a conversion rule; however, there isn&#8217;t a one-to-one link
between converters and conversion rules and the two are independent of
each other.</p>
<div class="section" id="converters">
<h3><a class="toc-backref" href="#id14">Converters</a><a class="headerlink" href="#converters" title="Permalink to this headline">¶</a></h3>
<p>To create a new converter, you must derive from the Converter interface
and implement the following:</p>
<div class="section" id="constructor">
<h4>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none"><div class="highlight"><pre><span></span>// Constructor
// \param params command line parameters for initialising the converter
Converter( const BW::string&amp; params )
</pre></div>
</div>
<p>The constructor for your converter must take a <code class="docutils literal"><span class="pre">params</span></code> string
parameter. Your constructor should defer to the base class constructor
which will store the <code class="docutils literal"><span class="pre">params</span></code> string in a member variable <code class="docutils literal"><span class="pre">params_</span></code>.
The <code class="docutils literal"><span class="pre">params</span></code> parameter can contain any optional parameters of your
choosing and is passed to your constructor from the asset pipeline via
the conversion rules (see <a class="reference internal" href="#conversion-rules">Conversion Rules</a>).</p>
</div>
<div class="section" id="createdependencies">
<h4>createDependencies<a class="headerlink" href="#createdependencies" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none"><div class="highlight"><pre><span></span>// builds the dependency list for a source file.
// \param sourcefile the name of the source file on disk.
// \param dependencies the dependency list to generate.
// \return true if the dependency list was successfully generated
virtual bool createDependencies( const BW::string&amp; sourcefile,
                                 const Compiler &amp; compiler,
                                 DependencyList &amp; dependencies )
</pre></div>
</div>
<p>This function must be overloaded to inform the asset pipeline of the
dependencies of the source file you wish to convert. The sourcefile
parameter contains the absolute path of the asset to convert. The
compiler parameter contains a reference to the front-end compiler that
has triggered this conversion. The dependencies parameters contains the
dependency list structure that must be filled out with the source
asset&#8217;s dependencies.</p>
</div>
<div class="section" id="convert">
<h4>convert<a class="headerlink" href="#convert" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none"><div class="highlight"><pre><span></span>// convert a source file.
// \param sourcefile the name of the source file on disk.
// \param convertedFiles a list of filenames that were converted from the source file.
// \return true if the source file was successfully converted.
virtual bool convert( const BW::string&amp; sourcefile,
                      const Compiler &amp; compiler,
                      BW::vector&lt; BW::string &gt; &amp; intermediateFiles,
                      BW::vector&lt; BW::string &gt; &amp; outputFiles )
</pre></div>
</div>
<p>This function must be overloaded to perform the actual conversion of
your source asset. The sourcefile parameter contains the absolute path
of the asset to convert. The compiler parameter contains a reference to
the front-end compiler that has triggered this conversion. The
intermediateFiles parameter contains a vector of strings to which you
must append the path of any intermediate file produced by your
conversion. The outputFiles parameter contains a vector of strings to
which you must append the path of any output file produced by your
conversion.</p>
</div>
</div>
<div class="section" id="absolute-vs-relative-paths">
<h3><a class="toc-backref" href="#id15">Absolute vs Relative Paths</a><a class="headerlink" href="#absolute-vs-relative-paths" title="Permalink to this headline">¶</a></h3>
<p>Internally the asset pipeline operates on absolute paths to avoid errors
with files with the same file name existing in multiple resource
directories. However, when adding files to the dependency list in the
createDependencies function, file names must first be converted to
relative paths. This is necessary as these file names get saved to disk
and shared via a file cache between multiple users, who may have
different resource path setups. Conversely, when pushing file names back
into the intermediateFiles and outputFiles outputs of the convert
function, these file names need to be absolute paths. The reason for
this is that the asset pipeline is required to hash the contents of
these files to store in the generated deps file, and by using absolute
paths we can ensure that the correct file is hashed.</p>
<p>There is, however, an important consideration that needs to be made when
converting between relative and absolute paths. The asset pipeline can
be run with custom intermediate and output directories. When resolving
an intermediate or output file to an absolute path, this path needs to
be resolved to the appropriate directory. As the intermediate and output
directories are unknown to the converters until run time, the compiler
interface provides a number of convenience functions for converting
between absolute and relative paths.</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">resolveRelativePath(</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">path</span> <span class="pre">)</span> <span class="pre">const</span></code></p>
<p>Converts the path to a relative path.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">resolveSourcePath(</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">path</span> <span class="pre">)</span> <span class="pre">const</span></code>
Converts the path to an absolute source path.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">resolveIntermediatePath(</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">path</span> <span class="pre">)</span> <span class="pre">const</span></code></p>
<p>Converts the path to an absolute intermediate path.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">resolveOutputPath(</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">path</span> <span class="pre">)</span> <span class="pre">const</span></code></p>
<p>Converts the path to an absolute output path.</p>
</li>
</ul>
<p>In summary, before adding a file to a dependency list, call
<code class="docutils literal"><span class="pre">resolveRelativePath</span></code>. Before adding a file to the intermediate files
list, call <code class="docutils literal"><span class="pre">resolveIntermediatePath</span></code>. Before adding a file to the
output files list, call <code class="docutils literal"><span class="pre">resolveOutputPath</span></code>. Also note, it is the
responsibility of the converter to save any files it outputs to the
appropriate directories. It is good practice to work with absolute paths
during conversion where possible.</p>
</div>
<div class="section" id="dependency-list">
<h3><a class="toc-backref" href="#id16">Dependency List</a><a class="headerlink" href="#dependency-list" title="Permalink to this headline">¶</a></h3>
<p>When pushing back dependencies in the createDependencies function, there
are a number of options. Assets are currently allowed to have the
following types of dependencies: source file dependencies, intermediate
file dependencies, output file dependencies, directory dependencies,
converter dependencies, and converter parameter dependencies.</p>
<ul class="simple">
<li><strong>Source file dependencies</strong> are when an asset file depends on
another raw source asset. This dependency indicates that the file it
depends on does not need any sort of processing by the asset
pipeline.</li>
<li><strong>Intermediate file dependencies</strong> and <strong>output file dependencies</strong>
occur when an asset file depends on another compiled asset. These
types of dependencies tell the asset pipeline that a subtask has to
be initiated to convert a source asset into a compiled format before
the conversion of the current asset can take place. The only
difference between intermediate and output file dependencies is the
location where the compiled asset is expected to reside.</li>
<li><strong>Directory dependencies</strong> allow an asset to recursively depend on a
directory of assets. Directory dependencies can use a regex pattern
to filter all files in a directory into a smaller subset of files.</li>
<li><strong>Converter dependencies</strong> allow an asset to depend on a certain
version of a converter, and <strong>converter parameter dependencies</strong>
allow an asset to depend on the parameter string that is passed to
the converter&#8217;s constructor. These last two dependency types are only
used internally by the asset pipeline system.</li>
</ul>
<p>All dependencies can be marked as critical or non critical. A critical
dependency is a dependency that must exist for the parent asset to be
converted. If an error is encountered in a critical dependency, it will
automatically fail the parent asset. A converter should ideally be
designed to have as few critical dependencies as possible.</p>
<p>The DependencyList class provides the following functions for adding
dependencies:</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addPrimarySourceFileDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></p>
<p>Adds a primary source file dependency. The filename parameter
specifies the name of the file to depend on.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addPrimaryConverterDependency(</span> <span class="pre">size_t</span> <span class="pre">converterId,</span> <span class="pre">size_t</span> <span class="pre">converterVersion</span> <span class="pre">)</span></code></p>
<p>Adds a primary converter dependency. The converterId parameter
specifies the id of the converter to depend on, converterVersion
specifies the version of the converter to depend on.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addPrimaryConverterParamsDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">converterParams</span> <span class="pre">)</span></code></p>
<p>Adds a primary converter params dependency. The convertParams
parameter specifies the parameter string to depend on.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addSecondarySourceFileDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename,</span> <span class="pre">bool</span> <span class="pre">critical</span> <span class="pre">)</span></code></p>
<p>Adds a secondary source file dependency. The filename parameter
specifies the name of the file to depend on, and critical specifies
whether this is a critical dependency.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addSecondaryIntermediateFileDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename,</span> <span class="pre">bool</span> <span class="pre">critical</span> <span class="pre">)</span></code></p>
<p>Adds a secondary intermediate file dependency. The filename parameter
specifies the name of the compiled file to depend on, and critical
specifies whether this is a critical dependency.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addSecondaryOutputFileDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename,</span> <span class="pre">bool</span> <span class="pre">critical</span> <span class="pre">)</span></code></p>
<p>Adds a secondary output file dependency. The filename parameter
specifies the name of the compiled file to depend on, and critical
specifies whether this is a critical dependency.</p>
<p><code class="docutils literal"><span class="pre">void</span> <span class="pre">addSecondaryDirectoryDependency(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">directory,</span></code>
<code class="docutils literal"><span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">pattern,</span> <span class="pre">bool</span> <span class="pre">recursive,</span> <span class="pre">bool</span> <span class="pre">critical</span> <span class="pre">)</span></code></p>
<p>Adds a secondary directory dependency. The pattern parameter
specifies a regex pattern to match files within a directory,
specified by the directory parameter, to depend on. Recursive
specifies whether the pattern should be applied recursively to the
directory and critical specifies whether this is a critical
dependency.</p>
</div>
<div class="section" id="errors-and-exceptions">
<h3><a class="toc-backref" href="#id17">Errors and Exceptions</a><a class="headerlink" href="#errors-and-exceptions" title="Permalink to this headline">¶</a></h3>
<p>The asset pipeline is designed to be run as an unattended process.
Because of this we need to prevent asserts from halting the conversion
process. As such all calls into the converters are wrapped in try/catch
blocks. When an assert is fired, the asset pipeline swallows the assert
and throws an exception. The exception is then caught by the task
processor and the currently processing task is failed. The assert
information is added to the error log of the task and the asset pipeline
is able to continue on. Additionally, the asset pipeline handles the
ERROR_MSG macro. When this macro is triggered within a converter, the
currently processing task is marked with an error. Processing is allowed
to continue on the task, but on completion the task is set as failed and
the message added to the error log of the task.</p>
<p>Whilst processing a task, if your converter encounters an error and
wishes to fail the current task without using an assert or an error
message, simply return false from the createDependencies or convert
function of your converter. This will set the current task as failed. If
a task fails during the createDependencies function, the asset pipeline
will not attempt to call the convert function.</p>
</div>
<div class="section" id="conversion-rules">
<h3><a class="toc-backref" href="#id18">Conversion Rules</a><a class="headerlink" href="#conversion-rules" title="Permalink to this headline">¶</a></h3>
<p>To create a conversion rule you must implement the ConversionRule
interface.</p>
<p>A conversion rule takes a single boolean argument in its constructor:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ConversionRule( bool bRoot )
</pre></div>
</div>
<p>The bRoot argument indicates whether a conversion rule is a root rule or
a non-root rule. Root rules are rules used during the discovery phase of
the asset pipeline to match files on disk to conversion tasks. Non-root
rules are used to resolve tasks for sub dependencies of other tasks.</p>
<p>For example, if we had a rule to match source texture files to texture
conversion tasks and we flagged this rule as a root rule, the discovery
phase of the asset pipeline would identify tasks for every source
texture on disk. However, if we were to flag this rule as a non-root
rule, the discovery phase of the asset pipeline would not find any
texture conversion tasks. During the conversion phase of the asset
pipeline, if another task is processed and found to have a dependency on
a compiled texture, the non-root texture conversion rule is queried to
create the texture conversion task. In this way, by carefully selecting
which conversion rules are flagged as root rules, we can ensure that
only assets referenced by root assets are compiled and packaged to the
output directory.</p>
<p>For a conversion rule to match a source asset file name to a conversion
task, the following function must be overloaded:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* returns true and populates a conversion task if the rule can match the input filename. */
virtual bool createTask( const BW::StringRef&amp; sourceFile, ConversionTask&amp; task )
</pre></div>
</div>
<p>This function is invoked by the asset pipeline whenever it tries to
determine how to build a source asset. If your conversion rule is able
to handle the asset passed in by the parameter sourceFile, you must
initialise the task structure and return true. The task structure
requires that you set the id, version, and parameters of the converter
that will handle the conversion of this asset.</p>
<p>If your rule is a non-root rule (it is intended to be invoked when
processing the dependencies of other assets), you must also overload the
following function:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* returns true if the rule can match the output filename. */
virtual bool getSourceFile( const BW::StringRef&amp; file, BW::string&amp; sourcefile ) const
</pre></div>
</div>
<p>This function is invoked by the asset pipeline whenever it tries to
determine what source file is used to create a compiled dependency file.
In this case, the parameter file will contain the file name of the
compiled file the asset pipeline is trying to compile. If your
conversion rule knows what source asset file is used to convert into
this file, it should fill in the sourcefile parameter and return true.</p>
</div>
</div>
<div class="section" id="writing-compilers">
<span id="id1"></span><h2><a class="toc-backref" href="#id19">Writing Compilers</a><a class="headerlink" href="#writing-compilers" title="Permalink to this headline">¶</a></h2>
<p>The asset pipeline supports the creation of custom front-end interfaces.
These interfaces enable users to interact with the asset conversion
process. In the asset pipeline framework, these front-end interfaces are
known as compilers.</p>
<div class="section" id="asset-compiler">
<h3><a class="toc-backref" href="#id20">Asset Compiler</a><a class="headerlink" href="#asset-compiler" title="Permalink to this headline">¶</a></h3>
<p>Any custom front-end compiler you write must inherit from the
AssetCompiler base class. The AssetCompiler class provides a number of
overloadable callback functions that are called by the asset pipeline
during different stages of the discovery and conversion phases. In most
cases where a compiler callback has been overloaded, it is important
that the base class implementation of the overloaded function is called
at some point during your own callback handling code. In some cases, not
doing so can cause the asset pipeline to fail.</p>
<p>Below are some of the more useful callbacks that you can overload.</p>
</div>
<div class="section" id="discovery-callbacks">
<h3><a class="toc-backref" href="#id21">Discovery Callbacks</a><a class="headerlink" href="#discovery-callbacks" title="Permalink to this headline">¶</a></h3>
<p>The following callbacks are invoked during the discovery phase:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">shouldIterateFile(</span> <span class="pre">const</span> <span class="pre">BW::StringRef</span> <span class="pre">&amp;</span> <span class="pre">file</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">shouldIterateDirectory(</span> <span class="pre">const</span> <span class="pre">BW::StringRef</span> <span class="pre">&amp;</span> <span class="pre">directory</span> <span class="pre">)</span></code></li>
</ul>
<p>These callbacks are invoked whenever the task finder attempts to iterate
a file or directory whilst searching for potential source assets. By
returning false from either of these functions, you can tell the asset
pipeline to ignore certain files or directories.</p>
</div>
<div class="section" id="task-callbacks">
<h3><a class="toc-backref" href="#id22">Task Callbacks</a><a class="headerlink" href="#task-callbacks" title="Permalink to this headline">¶</a></h3>
<p>The following callbacks are invoked during the conversion phase:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onTaskStarted(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onTaskResumed(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onTaskSuspended(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">onTaskCompleted(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
</ul>
<p>These callbacks are invoked by the task processor whilst processing
conversion tasks. They provide a mechanism for notifying the compiler of
the tasks that are currently executing. If you overload these callbacks,
it is extremely important to call the base implementation, as the
AssetCompiler uses these callbacks to manage the processing of dependent
tasks and catching cyclic dependencies.</p>
</div>
<div class="section" id="converter-callbacks">
<h3><a class="toc-backref" href="#id23">Converter Callbacks</a><a class="headerlink" href="#converter-callbacks" title="Permalink to this headline">¶</a></h3>
<p>These callbacks are invoked by the task processor prior to and after the
createDependencies function on a converter is invoked and prior to and
after the convert function on a converter is invoked. Once again, if you
overload these callbacks, make sure you call the base implementation.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onPreCreateDependencies(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onPostCreateDependencies(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onPreConvert(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onPostConvert(</span> <span class="pre">ConversionTask</span> <span class="pre">&amp;</span> <span class="pre">conversionTask</span> <span class="pre">)</span></code></li>
</ul>
</div>
<div class="section" id="conversion-callback">
<h3><a class="toc-backref" href="#id24">Conversion Callback</a><a class="headerlink" href="#conversion-callback" title="Permalink to this headline">¶</a></h3>
<p>This callback is invoked for every intermediate and output file that is
generated by the asset pipeline. Note, if an output file is not
generated during a run of the asset pipeline, due to files being up to
date, this callback will not be invoked.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">onOutputGenerated(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></li>
</ul>
</div>
<div class="section" id="cache-callbacks">
<h3><a class="toc-backref" href="#id25">Cache Callbacks</a><a class="headerlink" href="#cache-callbacks" title="Permalink to this headline">¶</a></h3>
<p>These callbacks are invoked whenever the asset pipeline attempts to read
or write from the shared file cache. If a cache read or write is
successful, the onCacheRead and onCacheWrite callbacks will be invoked.
If a cache read or write is not successful, due to network or disk
errors or a file not existing in the cache, the onCacheReadMiss and
onCacheWriteMiss callbacks are invoked.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">onCacheRead(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">onCacheReadMiss(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">onCacheWrite(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></li>
<li><code class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">onCacheWriteMiss(</span> <span class="pre">const</span> <span class="pre">BW::string</span> <span class="pre">&amp;</span> <span class="pre">filename</span> <span class="pre">)</span></code></li>
</ul>
</div>
<div class="section" id="message-callbacks">
<h3><a class="toc-backref" href="#id26">Message Callbacks</a><a class="headerlink" href="#message-callbacks" title="Permalink to this headline">¶</a></h3>
<p>These callbacks are invoked whenever a BigWorld Technology message macro
is used. The intention of these callbacks is to enable the compilers to
filter message spam from BigWorld Technology systems and choose which
messages to display, and how to display them to the user. These
callbacks are also integral to the operation of the asset pipeline, so
if you choose to overload these functions, make sure you call the base
implementations.</p>
<div class="code python highlight-none"><div class="highlight"><pre><span></span>virtual bool handleMessage( DebugMessagePriority componentPriority, DebugMessagePriority messagePriority, const BW::string &amp; category, DebugMessageSource messageSource, const char * format, va_list argPtr )
</pre></div>
</div>
<div class="code python highlight-none"><div class="highlight"><pre><span></span>virtual void handleCritical( const char * msg )
</pre></div>
</div>
</div>
</div>
<div class="section" id="registering-converters-and-conversion-rules">
<span id="id2"></span><h2><a class="toc-backref" href="#id27">Registering Converters and Conversion Rules</a><a class="headerlink" href="#registering-converters-and-conversion-rules" title="Permalink to this headline">¶</a></h2>
<p>One of the responsibilities of the compiler front end is to manage the
converters and conversion rules that are used by the asset pipeline
framework. The AssetCompiler base class provides two functions to this
end:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>virtual void registerConversionRule( ConversionRule&amp; conversionRule );
virtual void registerConverter( ConverterInfo&amp; converterInfo );
</pre></div>
</div>
<p>Registering conversion rules is a straight forward process. An instance
of the conversion rule must be created and then passed to the
registerConversionRule function. Registering converters is a little more
complicated. To register a converter, an instance of the following
structure must be passed to the registerConverter function.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/// struct containing information about a converter in the asset pipeline.
struct ConverterInfo
{
public:
    /// the display name of the converter.
    BW::string name_;
    /// the id of the converter. Must be unique to each type of converter.
    size_t typeId_;
    /// the current version of the converter.
    size_t version_;
    /// converter flags
    enum
    {
        THREAD_SAFE         = 1 &lt;&lt; 0, // can the converter be run on multiple threads.
        CACHE_DEPENDENCIES  = 1 &lt;&lt; 1, // should dependencies be read and written to the cache.
        CACHE_CONVERSION    = 1 &lt;&lt; 2, // should conversion be read and written to the cache.
        DEFAULT_FLAGS       = THREAD_SAFE | CACHE_DEPENDENCIES | CACHE_CONVERSION
    }                   flags_;
    /// function pointer for creating an instance of the converter.
    ConverterCreator    creator_;
};
</pre></div>
</div>
<p>This structure contains all the necessary information for the asset
pipeline to instantiate converters to process tasks. The reason we do
not simply register an instance of the converter on the compiler, as we
do the conversion rules, is because the asset pipeline can process tasks
on multiple threads, meaning more than one converter of the same type
may be required at any one time. Allowing the asset pipeline to create
converters on the fly avoids the need for converters to manage thread
local storage or thread locks around member variables.</p>
<p>A standard practice for managing converter info structures is to define
the following on your converter class definition:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/// MyConverter.hpp
static size_t getTypeId() { return s_TypeId; }
static size_t getVersion() { return s_Version; }
static const char * getTypeName() { return &quot;MyConverter&quot;; }
static Converter * createConverter( const BW::string&amp; params ) { return new MyConverter( params ); }
static const size_t s_TypeId;
static const size_t s_Version;
/// MyConverter.cpp
const size_t MyConverter::s_TypeId = hash_string( MyConverter::getTypeName(), strlen( MyConverter::getTypeName()));
const size_t MyConverter::s_Version = 1;
</pre></div>
</div>
<p>Defining your converter info then becomes:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ConverterInfo myConverterInfo;
myConverterInfo.name_ = MyConverter::getTypeName();
myConverterInfo.typeId_ = MyConverter::getTypeId();
myConverterInfo.version_ = MyConverter::getVersion();
myConverterInfo.flags_ = myConverterFlags;
myConverterInfo.creator_ = MyConverter::createConverter;
</pre></div>
</div>
<p>A convenience macro exists to allow you to then replace this with:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ConverterInfo myConverterInfo;
INIT_CONVERTER_INFO( myConverterInfo, ConverterInfo , myConverterFlags);
</pre></div>
</div>
<div class="section" id="initiating-a-build">
<h3><a class="toc-backref" href="#id28">Initiating a Build</a><a class="headerlink" href="#initiating-a-build" title="Permalink to this headline">¶</a></h3>
<p>Once all converters and conversion rules have been registered, a
compiler can initiate a build. Compilers have access to both the
discovery phase of the asset pipeline, through the taskFinder_ member,
and the conversion phase of the asset pipeline, through the
taskProcessor_ member.</p>
<p>To initiate a search for all source assets that match any of the
registered root rules, call the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>taskFinder_.findTasks( path );
</pre></div>
</div>
<p>where path is the directory or file to search.</p>
<p>To get the specific task for a source asset that matched either a root
rule or a non-root rule, call the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ConversionTask &amp; task = taskFinder_.getTask( file );
if (task.converterId_ != ConversionTask::s_unknownId)
{
    queueTask( task );
}
</pre></div>
</div>
<p>In this case, it is necessary to manually queue the conversion task so
that it will be processed during the conversion phase.</p>
<p>To initiate the conversion phase, simply call:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>taskProcessor_.processTasks();
</pre></div>
</div>
</div>
</div>
<div class="section" id="writing-plugins">
<h2><a class="toc-backref" href="#id29">Writing Plugins</a><a class="headerlink" href="#writing-plugins" title="Permalink to this headline">¶</a></h2>
<p>The asset pipeline was designed with a DLL plugin architecture in mind.
Although a compiler can be implemented without using the plugin
framework, there are a number of benefits to using plugins. By using a
plugin framework, converter DLLs can be built once and distributed
between different compiler front ends. Also, developing a new converter
plugin does not require a rebuild of all the different compiler front
ends that may exist. This prevents changes to converter plugins,
introducing bugs into the compiler executable.</p>
<div class="section" id="plugin-loader">
<h3><a class="toc-backref" href="#id30">Plugin Loader</a><a class="headerlink" href="#plugin-loader" title="Permalink to this headline">¶</a></h3>
<p>To allow a compiler to make use of the asset pipeline plugin system, a
compiler must inherit from the PluginLoader class.</p>
<p>The PluginLoader class provides a number of functions for loading and
unloading converter DLLs.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void initPlugins();
void finiPlugins();
HMODULE loadPlugin( LPCWSTR plugin );
bool unloadPlugin( HMODULE plugin );
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">initPlugins</span></code> reads a file named &#8220;&lt;executable&gt;_plugins.txt&#8221; and
loads the appropriate (debug or hybrid) plugin DLLs specified within.</li>
<li><code class="docutils literal"><span class="pre">finiPlugins</span></code> unloads all currently loaded DLLs.</li>
<li><code class="docutils literal"><span class="pre">loadPlugin</span></code> loads the plugin with file name plugin.</li>
<li><code class="docutils literal"><span class="pre">unloadPlugin</span></code> unloads a specific loaded plugin by its HMODULE.</li>
</ul>
<p>When using these functions to load converter plugins, it is the
responsibility of the converter plugin code to register conversion rules
and converters with your compiler.</p>
</div>
<div class="section" id="converter-plugin">
<h3><a class="toc-backref" href="#id31">Converter Plugin</a><a class="headerlink" href="#converter-plugin" title="Permalink to this headline">¶</a></h3>
<p>To create a converter plugin there are two functions that your DLL must
expose. When scanning for potential plugins to load, the plugin loader
will search for these functions to determine whether your plugin can be
loaded. These functions are defined differently on debug and hybrid
builds. This allows debug and hybrid configurations of your DLLs to
reside side by side in a file directory whilst still ensuring that the
plugin loader can, and will, only load the appropriate configuration
version of your DLL. To facilitate exposing the correct dll functions
based on configuration, use the macros PLUGIN_INIT_FUNC and
PLUGIN_FINI_FUNC.</p>
<p>The following is an example of how to write a converter plugin:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>BW_BEGIN_NAMESPACE
DECLARE_APP_DATA( &quot;MyConverter&quot;, true )
MyConversionRule myConversionRule;
ConverterInfo myConverterInfo;

PLUGIN_INIT_FUNC
{

    Compiler * compiler = dynamic_cast&lt; Compiler * &gt;( &amp;pluginLoader );
    if (compiler == NULL)
    {
        return false;
    }

    // Init any systems required by your converter
    INIT_CONVERTER_INFO( myConverterInfo, MyConverter, DEFAULT_FLAGS );
    compiler-&gt;registerConversionRule( myConversionRule );
    compiler-&gt;registerConverter( myConverterInfo );
    return true;
}

PLUGIN_FINI_FUNC
{
    // Fini any systems that were started by your converter
    return true;
}

BW_END_NAMESPACE
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">DECLARE_APP_DATA</span></code> macro is a convenience macro to set up a number
of global constant values that allow the core BigWorld Technology
systems to be run in a plugin. The first parameter of this macro is a
unique identifier for your plugin, and the second is a boolean to
indicate that the current module is being compiled as a plugin.</p>
<p>The <code class="docutils literal"><span class="pre">PLUGIN_INIT_FUNC</span></code> macro automatically generates an exposed
function that gets called when your plugin is loaded. This function
takes one argument: pluginLoader. As shown in the example above, you can
verify the module attempting to load your plugin is actually a compiler
by dynamically casting the pluginLoader argument to a Compiler object.
If the cast fails, the function should return false.</p>
<p>The <code class="docutils literal"><span class="pre">PLUGIN_FINI_FUNC</span></code> macro automatically generates an exposed
function that gets called when your plugin is unloaded.</p>
</div>
</div>
<div class="section" id="writing-unit-tests">
<span id="id3"></span><h2><a class="toc-backref" href="#id32">Writing Unit Tests</a><a class="headerlink" href="#writing-unit-tests" title="Permalink to this headline">¶</a></h2>
<p>The final step in writing a converter plugin for the asset pipeline is
to write unit tests. To make this as easy as possible, a custom
front-end compiler is provided. The TestCompiler provides a number of
convenience functions that can be used to easily test conversion rules
and converters.</p>
<p>To test a conversion rule, use the following function:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>// Test that a conversion rule can be found for a source file
bool testConversionRule( const StringRef &amp; sourceFile,
                         const StringRef &amp; outputFile,
                         const StringRef &amp; converterName,
                         const StringRef &amp; converterParams );
</pre></div>
</div>
<p>This function takes a source asset file name, the expected output file,
the expected name of the converter that would convert this asset, and
the expected conversion parameters for this asset. If a source asset is
expected to compile to more than one output file, this function should
be called for each of the individual output file names.</p>
<p>There are several steps involved to test a converter.</p>
<p>First, the test needs to be set up. To set up a test we must provide the
TestCompiler with the source files to convert. Optionally, we can also
provide copies of the output files we expect to be produced by the
conversion process. The following functions are provided for setting up
a converter test:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>// Set the directory where the source files for this test can be found
bool setSourceFileDirectory( const StringRef &amp; sourceFileDirectory );
// Set the directory where the output files for this test can be found
bool setOutputFileDirectory( const StringRef &amp; outputFileDirectory );
// Add a file from the source file directory that should be used in this test

bool addSourceFile( const StringRef &amp; sourceFile );
// Add a file from the output file directory that should be built in this test

bool addOutputFile( const StringRef &amp; outputFile );
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">setSourceFileDirectory</span></code> function tells the TestCompiler where to
find the source assets to use for the test. The
<code class="docutils literal"><span class="pre">setOutputFileDirectory</span></code> functiion tells the TestCompiler where to
find the output files to verify the conversion process against. The
<code class="docutils literal"><span class="pre">addSourceFile</span></code> and <code class="docutils literal"><span class="pre">addOutputFile</span></code> functions tell the TestCompiler
which files in the source directory and output directory to use for the
test.</p>
<p>After the test has been set up, it can be run with one of the following
functions:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>// Trigger a test build for a single file
bool testBuildFile( const StringRef &amp; file );

// Trigger a test build for a directory
bool testBuildDirectory( const StringRef &amp; directory );
</pre></div>
</div>
<p>The testBuildFile function tests building a single file. The
testBuildDirectory function tests building an entire directory of files.
The input to these functions should be the source asset or directory to
build relative to the source file directory. Normally you will want to
call testBuildDirectory with an empty directory parameter to build every
source asset in the source file directory.</p>
<p>When the TestCompiler finishes building your assets it will
automatically verify that the outputs produced by the asset pipeline
exactly match the copies of the expected outputs that you provided when
setting up the test. If you did not provide any expected outputs to the
test setup then the TestCompiler will assume the conversion process
completed successfully. The TestCompiler then provides the following
functions to further verify the results of the conversion process:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>// Get the number of tasks that were processed by this test
long getTaskCount() const { return taskCount_; }

// Get the number of tasks that were failed by this test
long getTaskFailedCount() const { return taskFailedCount_; }

// Returns if this test encountered a cyclic error
bool hasCyclicError() const { return hasCyclicError_; }
// Returns if this test encountered a dependency error
bool hasDependencyError() const { return hasDependencyError_; }
// Returns if this test encountered a conversion error
bool hasConversionError() const { return hasConversionError_; }
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">getTaskCount</span></code> allows you to verify how many tasks were actually
processed.</li>
<li><code class="docutils literal"><span class="pre">getTaskFailedCount</span></code> allows you to verify how many of these tasks
failed, as you may wish to test certain situations in which your
converter should fail.</li>
<li><code class="docutils literal"><span class="pre">hasCyclicError</span></code> will tell you if a cyclic dependency error occured
during conversion.</li>
<li><code class="docutils literal"><span class="pre">hasDependencyError</span></code> will tell you if any task reported an error
during the createDependencies function of your converter.</li>
<li><code class="docutils literal"><span class="pre">hasConversionError</span></code> will tell you if any task reported an error
during the convert function of your converter.</li>
</ul>
<p>After the TestCompiler finishes its testing, it will automatically clean
up any changes it may have made on disk and return.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="assetrules.html" class="btn btn-neutral float-right" title="Asset Rules" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="utilityclasses.html" class="btn btn-neutral" title="Utility Classes" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Wargaming Sydney.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>